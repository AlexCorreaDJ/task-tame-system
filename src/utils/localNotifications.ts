import {
  LocalNotifications,
  PermissionStatus,
  LocalNotification,
  Schedule,
} from '@capacitor/local-notifications';
import { Capacitor } from '@capacitor/core';

export const isNativePlatform = (): boolean => {
  return Capacitor.isNativePlatform();
};

export const requestLocalNotificationPermission = async (): Promise<boolean> => {
  const permission: PermissionStatus = await LocalNotifications.requestPermissions();
  return permission.display === 'granted';
};

export const scheduleLocalNotification = async (
  notification: LocalNotification,
  schedule?: Schedule
): Promise<void> => {
  await LocalNotifications.schedule({
    notifications: [
      {
        id: notification.id,
        title: notification.title,
        body: notification.body,
        sound: notification.sound || undefined,
        schedule: schedule || undefined,
        extra: notification.extra || undefined,
        smallIcon: notification.smallIcon || undefined,
        iconColor: notification.iconColor || undefined,
        group: notification.group || undefined,
      },
    ],
  });
};

export const showLocalNotification = async (
  notification: LocalNotification
): Promise<void> => {
  // Agendar notifica√ß√£o para disparar imediatamente (sem schedule)
  await scheduleLocalNotification(notification);
};

export const cancelLocalNotification = async (id: number): Promise<void> => {
  await LocalNotifications.cancel({ notifications: [{ id }] });
};

export const cancelAllLocalNotifications = async (): Promise<void> => {
  const pending = await LocalNotifications.getPending();
  if (pending.notifications.length > 0) {
    await LocalNotifications.cancel({ notifications: pending.notifications });
  }
};

export const getScheduledLocalNotifications = async (): Promise<LocalNotification[]> => {
  const result = await LocalNotifications.getPending();
  return result.notifications;
};

export const testLocalNotification = async (): Promise<boolean> => {
  try {
    await showLocalNotification({
      id: 999,
      title: "üß™ Teste de Notifica√ß√£o",
      body: "Esta √© uma notifica√ß√£o de teste! üì±‚ú®"
    });
    return true;
  } catch (error) {
    console.error('Erro ao testar notifica√ß√£o:', error);
    return false;
  }
};

export const initializeLocalNotifications = async (): Promise<boolean> => {
  if (!isNativePlatform()) {
    console.log('üåê N√£o √© app nativo, pulando inicializa√ß√£o de notifica√ß√µes locais');
    return false;
  }

  try {
    const permission = await requestLocalNotificationPermission();
    if (permission) {
      console.log('‚úÖ Notifica√ß√µes locais inicializadas com sucesso');
      return true;
    } else {
      console.log('‚ùå Permiss√£o de notifica√ß√£o negada');
      return false;
    }
  } catch (error) {
    console.error('‚ùå Erro ao inicializar notifica√ß√µes locais:', error);
    return false;
  }
};

export const scheduleReminderForToday = async (
  title: string,
  body: string,
  time: string, // Formato HH:MM
  extra?: any
): Promise<boolean> => {
  try {
    const [hours, minutes] = time.split(':').map(Number);

    if (isNaN(hours) || isNaN(minutes)) {
      throw new Error(`Formato inv√°lido para hor√°rio: ${time}`);
    }

    const now = new Date();
    const scheduleDate = new Date();
    scheduleDate.setHours(hours, minutes, 0, 0);

    if (scheduleDate <= now) {
      scheduleDate.setDate(scheduleDate.getDate() + 1);
    }

    const schedule: Schedule = { at: scheduleDate };

    await scheduleLocalNotification(
      {
        id: Date.now(), // Aten√ß√£o a poss√≠veis ids duplicados em chamadas r√°pidas
        title,
        body,
        extra,
      },
      schedule
    );

    console.log('‚úÖ Lembrete agendado para:', scheduleDate.toLocaleString());
    return true;
  } catch (error) {
    console.error('‚ùå Erro ao agendar lembrete:', error);
    return false;
  }
};
